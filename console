#!/bin/bash

# dependencies #

# script #

script=$(basename -- "${BASH_SOURCE[0]}")

# usage #

# version #

version="02-26-2021"

# variables #

stamp=$(date +"%m-%d-%Y-%H-%M-%S")

# colors #

if [ -z "$(command -v tput)" ]
then
	if [[ -t 1 ]]
	then
		black=$(echo -e \\e\[30m)
		red=$(echo -e \\e\[31m)
		green=$(echo -e \\e\[32m)
		yellow=$(echo -e \\e\[33m)
		blue=$(echo -e \\e\[34m)
		magenta=$(echo -e \\e\[35m)
		cyan=$(echo -e \\e\[36m)
		white=$(echo -e \\e\[97m)
		reset=$(echo -e \\e\[39m)
	fi
else
	if [[ -t 1 ]]
	then
		black=$(tput setaf 0)
		red=$(tput setaf 1)
		green=$(tput setaf 2)
		yellow=$(tput setaf 3)
		blue=$(tput setaf 4)
		magenta=$(tput setaf 5)
		cyan=$(tput setaf 6)
		white=$(tput setaf 7)
		reset=$(tput sgr0)
	fi
fi

# symbols #

# markers

marker_maru='[ ○ ]'
marker_batsu='[ ⨉ ]'
marker_bako='[ □ ]'
marker_sankaku='[ △ ]'

marker_top='[ ⋀ ]'
marker_bot='[ ⋁ ]'

marker_fwd='[ > ]'
marker_rev='[ < ]'
marker_stp='[ / ]'

marker_add='[ + ]'
marker_rem='[ - ]'

marker_ask='[ ? ]'
marker_inf='[ i ]'
marker_ipt='[ ± ]'
marker_msg='[ ¤ ]'
marker_wrn='[ ! ]'
marker_usr='[ • ]'

marker_yes='[ ✓ ]'
marker_no='[ ⨉ ]'

# prompt #

console.prompt () {
	input="$@"

	IFS=' '

	[ -z "${1}" ] && exit 1

	padding_character="${2}"
	answer="${3}"

	padding_count=79
	padding_string=$(printf "%0.1s" "${padding_character}"{1..79}})

	# parse input:
	# typical formatting as "prompt" "padding character" "answer"

	for prompt in "${1}"
	do
		string_1=$(printf "%s" "${prompt}")

		[ -z "${answer}" ] && printf "\n" && break

		string_2=$(printf "%*.*s" 0 $((padding_count - ${#prompt} - ${#answer} )) "$padding_string")
		string_3=$(printf "%s\n" ": ${answer}")

	done <<< "${input}"

	# reset IFS

	IFS=

	# return values as padded prompt string

	console_str+=("${string_1}${string_2}${string_3}")
}

# highlights #

console.red () {
	echo -e "${red}"${console_str[@]}"${reset}"
}

console.green () {
	echo -e "${green}"${console_str[@]}"${reset}"
}

console.yellow () {
	echo -e "${yellow}"${console_str[@]}"${reset}"
}

console.blue () {
	echo -e "${blue}"${console_str[@]}"${reset}"
}

console.magenta () {
	echo -e "${magenta}"${console_str[@]}"${reset}"
}

console.cyan () {
	echo -e "${cyan}"${console_str[@]}"${reset}"
}

# prompts #

console.maru () {
	echo -e "${green}${marker_maru}" ${console_str[@]}"${reset}"
}

console.batsu () {
	echo -e "${red}${marker_batsu}" ${console_str[@]}"${reset}"
}

console.bako () {
	echo -e "${white}${marker_bako}" ${console_str[@]}"${reset}"
}

console.sankaku () {
	echo -e "${cyan}${marker_sankaku}" ${console_str[@]}"${reset}"
}

console.ask () {
	echo -e "${magenta}${marker_ask}" ${console_str[@]}"${reset}"
}

console.inf() {
	echo -e "${blue}${marker_inf}" ${console_str[@]}"${reset}"
}

console.msg () {
	echo -e "${cyan}${marker_msg}" ${console_str[@]}"${reset}"
}

console.wrn () {
	echo -e "${yellow}${marker_wrn}" ${console_str[@]}"${reset}"
}

console.usr () {
	echo -e "${magenta}${marker_usr}" ${console_str[@]}"${reset}"
}

console.add () {
	echo -e "${blue}${marker_add}" ${console_str[@]}"${reset}"
}

console.rem () {
	echo -e "${red}${marker_rem}" ${console_str[@]}"${reset}"
}

console.fwd () {
	echo -e "${white}${marker_fwd}" ${console_str[@]}"${reset}"
}

console.rev () {
	echo -e "${white}${marker_rev}" ${console_str[@]}"${reset}"
}

console.stp () {
	echo -e "${white}${marker_stp}" ${console_str[@]}"${reset}"
}

console.dwl () {
	echo -e "${magenta}${marker_bot}" ${console_str[@]}"${reset}"
}

console.upl () {
	echo -e "${magenta}${marker_top}" ${console_str[@]}"${reset}"
}

console.scs () {
	echo -e "${green}${marker_yes}" ${console_str[@]}"${reset}"
}

console.err () {
	echo -e "${red}${marker_no}" ${console_str[@]}"${reset}"
}

console.ipt () {
	echo -n "${magenta}${marker_add}" ${console_str[@]}"${reset}"
}

# triggers #

# wait

console.wait () {
	wait="${1}"

	# wait in seconds

	[ -z "${debug}" ] && sleep "${wait}" || sleep 0
}


# countdown

console.countdown () {
	message="${1}"
	seconds="${2}"

	shift

	while [ "${seconds}" -gt 0 ]
	do
		echo -e "\r${marker_wrn} ${message} [ ${red}$((seconds--))${reset} ] seconds...\c"

		sleep 1
	done

	# additional 'echo' required due to carriage return

	echo
}

# spinner

console.progress () {
	# catch PID of last command

	PID=$!

	spinner="+×"
	before="[ "
	after="]"

	message="${1}"

	i=1

	while [ -d /proc/"${PID}" ]
	do
		echo -ne "\r${before} \b${spinner:i++%${#spinner}:1} ${after} ${message}\c "

		sleep 0.175
	done

	# additional 'echo' required due to carriage return

	echo
}

# handlers #

# directory

console.directory () {
	path="${1}"

	# ${2} - array

	list=(${@:2})

	for directory in ${list[@]}
	do
		console.add "Creating directory [ ${directory} ]."
		echo

		# create directory and set permissions

		[ ! -d "${path}"/"${directory}" ] && mkdir -p "${path}"/"${directory}" || :

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${directory}"
	done
}

# get

console.get () {
	console.dwl "Downloading [ ${file} ]."
	echo

	curl -sL "${source}/${file}" > "${path}"/"${file}"

	chmod a+rx "${path}"/"${file}"
}

# download

console.download () {
	source="${1}"
	path="${2}"

	# "${3}" - array - file list

	list=(${@:3}) 

	console.fwd "Loading..."
	echo

	if [ -z "${list}" ]
	then
		source="${1}"
		path="${2}"

		# "${3}" - variable - file

		file="${3}"

		console.get

	else
		for file in ${list[@]}
		do
			console.get
		done

		list=()
	fi
}

# upload

console.upload () {

	console.upl "Uploading [ ${file} ]."
	echo

}

# silence

console.silence () {
	command="$@"

	"${SHELL}" -c "${command}" >> "${PREFIX}"/var/log/"${script}"-"${stamp}".log 2>&1
}

# input

console.input () {
	list=($@)

	for value in "${list[@]}"
	do
		label=${value^}
		prompt="$(echo ${label} | sed 's/_/ /'): "

		console.ipt "${prompt}"

		[[ "${value}" = *password* ]] && read -s input || read input
		echo

		# prevent empty input

		while true
		do
			if [ -z "${input}" ]
			then
				echo
				console.err "${label} cannot be empty:"
				console.wrn "${label} is required for successful setup."
				echo

				console.ipt "${prompt}"

				[[ "${value}" = *password* ]] && read -s input || read input

			else
				break
			fi
		done

		console_rtn+=("${value}=${input}")
	done
}

console.empty () {
	while true
	do
		read input

		if [ -z ${input} ]
		then
			console.wrn "Input cannot be empty."
			console.wrn "Try again."
			echo
		else
			break
		fi
	done
}

# packages #

# install

console.install () {
	export DEBIAN_FRONTEND=noninteractive

	list=($@)

	command_install="sudo apt-get install --no-install-recommends"
	command_clean="apt-get clean"

	console.inf "Installing required packages."
	echo

	for package in ${list[@]}
	do
		if [ -z "$(command -v ${package})" ]
		then
			console.wrn "Required package '${package}' not present."
			echo

			# use '--no-install-recommends' option to keep bloat to a minimum

			console.silence "echo yes | ${command_install} ${package}" &

			console.progress "Installing [ ${package} ]..."
			echo
		else
			console.scs "Required package '${package}' already installed."
			echo

			console.fwd "Continuing..."
			echo

			:
		fi
	done

	# cleanup

	console.silence "${command_clean}" &

	console.progress "Cleaning..."
	echo
}

console.install-local () {
	export DEBIAN_FRONTEND=noninteractive

	directory="$1"

	if [ -d "${directory}" ]
	then
		for package in "${directory}"/*.deb
		do
			echo yes | apt-get install "${package}"
		done
	else
		console.wrn "No local packages to install."
		echo

		console.fwd " Continuing..."
		echo
	fi
}

# update

console.update () {
	export DEBIAN_FRONTEND=noninteractive

	command_update="apt-get update"

	console.inf "Updating repository and package information."
	echo

	console.silence "${command_update}" &

	console.progress "Updating..."
	echo
}

# upgrade

console.upgrade () {
	export DEBIAN_FRONTEND=noninteractive

	command_upgrade="apt-get upgrade"

	console.inf "Upgrading installed packages."
	echo

	console.silence "echo yes | ${command_upgrade}" &

	console.progress "Upgrading..."
	echo
}

console.purge () {
	export DEBIAN_FRONTEND=noninteractive

	list=($@)

	command_purge="sudo apt-get purge"
	command_clean="sudo apt-get autoremove"

	console.inf "Purging selected packages packages."
	echo

	for package in ${list[@]}
	do
		if [ ! -z "$(command -v ${package})" ]
		then
			console.wrn "Selected package '${package}' now purging.."
			echo

			console.silence "echo yes | ${command_purge} ${package}" &

			console.progress "Purging [ ${package} ]..."
			echo
		else
			console.scs "Selected package '${package}' not installed."
			echo

			console.fwd "Continuing..."
			echo

			:
		fi
	done

	# cleanup

	console.silence "${command_clean}" &

	console.progress "Cleaning..."
	echo
}

console.dialog () {

	# dialog window title

	title="${script%.sh} - ${1}"

	# gtk dialog - zenity

	g_dialog () {
		zenity						\
			--file-selection		\
			--multiple				\
			--directory				\
			--separator=$'\n'		\
			--title="$title"		"${@}"
	}

	# kde dialog - kdialog

	k_dialog () {
		kdialog						\
			--getopenfilename		\
			--multiple				\
			--separate-output		\
			--title "$title"		"${@}"
	}

	# define dialog usage

	if [[ -z $(command -v zenity) ]]
	then
		dialog=$(k_dialog)

	elif [[ -z $(command -v kdialog) ]]
	then
		dialog=$(g_dialog)
	else
_		console.err "No dialog binary present on system."
		console.inf "This utility must be run using the 'directory' option."
		echo
		console.fwd "Exiting..."
		echo

		exit 1
	fi
}

console.trap () {
	name="${1}"

	trap=$(mktemp /tmp/${name}.XXXXXX)
	trap 'rm -rf "${trap}"' EXIT
}

console.id.user () {
	console.inf "Current user name is ${SUDO_USER:-$USER}."
	sleep 1
}

console.clear () {
	console.wait 2
	clear
}

console.title () {
	title="${1}"
	description="${2}"
	version="${3}"

	console.msg "[ $title - $description [ Version $version ] ]"
	echo
}

console.run () {
	command="$@"
	
	# initial prompt clear
	
	console.clear

	# run script
	
	"${SHELL}" "${command}"
	
	# post-command clear
	
	console.clear
}
